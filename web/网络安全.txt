CSRF:
CSRF全拼为Cross Site Request Forgery，译为跨站请求伪造。是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，指攻击者盗用了你的身份，以你的名义发送恶意请求。
利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。
防御措施：
1.检查Referer字段，HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。这种办法有局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。
2.添加校验token，由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。
3.cooike 添加SameSite

XSS:
全称：Cross Site Script(跨站脚本),为了与层叠样式表css区分，将跨站脚本简写为XSS。通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使其他用户加载并执行攻击者恶意制造的网页程序。从攻击代码的工作方式可以分为三个类型:（1）持久型跨站：最直接的危害类型，跨站代码存储在服务器（数据库）。（2）非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。（3）DOM跨站（DOM XSS）：DOM（document object model文档对象模型），客户端脚本处理逻辑导致的安全问题。
防范措施:
1.不信任用户提交的任何内容，对所有用户提交内容进行可靠的输入验证,在表单提交或者url参数传递前，对需要的参数进行过滤,转译尖括号,斜杠,引号
2.实现Session 标记（session tokens）、CAPTCHA（验证码）系统或者HTTP引用头检查，以防功能被第三方网站所执行，对于用户提交信息的中的img等link，检查是否有重定向回本站、不是真的图片等可疑操作。
3.cookie 防盗。避免直接在cookie中泄露用户隐私，例如email、密码，等等；通过使cookie和系统IP绑定来降低cookie泄露后的危险。这样攻击者得到的cookie没有实际价值，很难拿来直接进行重放攻击。
4.确认接收的内容被妥善地规范化，仅包含最小的、安全的Tag（没有JavaScript），去掉任何对远程内容的引用（尤其是样式表和JavaScript），使用HTTPonly的cookie。
5.内容安全策略(CSP),XSS攻击利用的核心问题是浏览器无法区分旨在成为应用程序一部分的脚本以及第三方恶意注入的脚本。CSP定义了HTTP头，而不是盲目信任服务器提供的所有信息。

sql注入：
指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句。
防范措施：
1.对用户进行分级管理，严格控制用户的权限
2.对参数传值进行过滤
3.对数据库中关键信息进行加密

点击劫持
点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击
1.X-FRAME-OPTIONS
X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用iframe 嵌套的点击劫持攻击。
该响应头有三个值可选，分别是
DENY，表示页面不允许通过 iframe 的方式展示
SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示
2. JS 防御
if (self == top) {
  var style = document.getElementById('click-jack')
  document.body.removeChild(style)
} else {
  top.location = self.location
}